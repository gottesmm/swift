// RUN: %target-sil-opt -sil-ownership-verifier-enable-testing -ownership-verifier-textual-error-dumper -enable-sil-verify-all=0 -o /dev/null %s 2>&1 | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

final class LinkedListNode {
  var next: Optional<LinkedListNode>
  var data: Builtin.Int32
}

// File with known failures involving rebase borrows.

sil @get_linkedlist_node : $@convention(thin) () -> @owned LinkedListNode

// In this case, we make sure that the rebase_borrow acts as a borrow of the new
// base meaning that we emit errors that the rebase_borrow base has bases
// outside of its lifetime.
//
// CHECK-LABEL: Error#: 0. Begin Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Found non consuming use outside of the lifetime being verified.
// CHECK: Value:   %21 = begin_borrow %20 : $LinkedListNode        // users: %25, %22
// CHECK: User:   end_borrow %6 : $LinkedListNode                 // id: %33
// CHECK: Error#: 0. End Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK-LABEL: Error#: 1. Begin Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Found non consuming use outside of the lifetime being verified.
// CHECK: Value:   %21 = begin_borrow %20 : $LinkedListNode        // users: %25, %22
// CHECK: User:   %32 = copy_value %6 : $LinkedListNode           // user: %34
// CHECK: Error#: 1. End Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK-LABEL: Error#: 2. Begin Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Found non consuming use outside of the lifetime being verified.
// CHECK: Value:   %21 = begin_borrow %20 : $LinkedListNode        // users: %25, %22
// CHECK: User:   end_borrow %6 : $LinkedListNode                 // id: %30
// CHECK: Error#: 2. End Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK-LABEL: Error#: 3. Begin Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Found non consuming use outside of the lifetime being verified.
// CHECK: Value:   %21 = begin_borrow %20 : $LinkedListNode        // users: %25, %22
// CHECK: User:   %12 = ref_element_addr %6 : $LinkedListNode, #LinkedListNode.next // users: %17, %13
// CHECK: Error#: 3. End Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK-LABEL: Error#: 4. Begin Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Found non consuming use outside of the lifetime being verified.
// CHECK: Value:   %21 = begin_borrow %20 : $LinkedListNode        // users: %25, %22
// CHECK: User:   %8 = ref_element_addr %6 : $LinkedListNode, #LinkedListNode.data // user: %9
// CHECK: Error#: 4. End Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK-LABEL: Error#: 5. Begin Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
// CHECK: Found outside of lifetime use?!
// CHECK: Value:   %21 = begin_borrow %20 : $LinkedListNode        // users: %25, %22
// CHECK: Consuming User:   end_borrow %21 : $LinkedListNode                // id: %25
// CHECK: Non Consuming User:   br bb2(%22 : $LinkedListNode)                   // id: %27
// CHECK: Block: bb5
// CHECK: Error#: 5. End Error in Function: 'll_iterative_readonly_search_with_too_short_lifetime_base'
sil [ossa] @ll_iterative_readonly_search_with_too_short_lifetime_base : $@convention(thin) (@guaranteed LinkedListNode, @guaranteed LinkedListNode, Builtin.Int32) -> @owned Optional<LinkedListNode> {
bb0(%0 : @guaranteed $LinkedListNode, %0bad : @guaranteed $LinkedListNode, %1 : $Builtin.Int32):
  br bb1

bb1:
  %0a = begin_borrow %0 : $LinkedListNode
  br bb2(%0a : $LinkedListNode)

bb2(%inductionVar : @guaranteed $LinkedListNode):
  br bb3

bb3:
  %value = ref_element_addr %inductionVar : $LinkedListNode, #LinkedListNode.data
  %testVal = load [trivial] %value : $*Builtin.Int32
  %cmpResult = builtin "cmp_slt_Int32"(%testVal : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %cmpResult, bb4, bb5

bb4:
  %addr = ref_element_addr %inductionVar : $LinkedListNode, #LinkedListNode.next
  %loadVal = load_borrow %addr : $*Optional<LinkedListNode>
  switch_enum %loadVal : $Optional<LinkedListNode>, case #Optional.some!enumelt: bb4a, case #Optional.none!enumelt: bb4b

// We do not use the unwrapped value here since we need to ensure that the new
// induction variable is a borrow introducer, not a sub borrow.
bb4a(%unwrappedLoadedVal : @guaranteed $LinkedListNode):
  end_borrow %loadVal : $Optional<LinkedListNode>
  %unwrappedAddr = unchecked_take_enum_data_addr %addr : $*Optional<LinkedListNode>, #Optional.some!enumelt
  %loadedUnwrappedVal = load_borrow %unwrappedAddr : $*LinkedListNode
  %f = function_ref @get_linkedlist_node : $@convention(thin) () -> @owned LinkedListNode
  %newBad = apply %f() : $@convention(thin) () -> @owned LinkedListNode
  %newBadBorrow = begin_borrow %newBad : $LinkedListNode
  %nextVar = rebase_borrow %loadedUnwrappedVal : $LinkedListNode on %newBadBorrow : $LinkedListNode
  end_borrow %loadedUnwrappedVal : $LinkedListNode
  end_borrow %inductionVar : $LinkedListNode
  end_borrow %newBadBorrow : $LinkedListNode
  destroy_value %newBad : $LinkedListNode
  br bb2(%nextVar : $LinkedListNode)

bb4b:
  %noneResult = enum $Optional<LinkedListNode>, #Optional.none!enumelt
  end_borrow %loadVal : $Optional<LinkedListNode>
  end_borrow %inductionVar : $LinkedListNode
  br bb6(%noneResult : $Optional<LinkedListNode>)

bb5:
  %result = copy_value %inductionVar : $LinkedListNode
  end_borrow %inductionVar : $LinkedListNode
  %wrappedResult = enum $Optional<LinkedListNode>, #Optional.some!enumelt, %result : $LinkedListNode
  br bb6(%wrappedResult : $Optional<LinkedListNode>)

bb6(%wrappedResult2 : @owned $Optional<LinkedListNode>):
  return %wrappedResult2 : $Optional<LinkedListNode>
}
