// RUN: %target-sil-opt -sil-ownership-verifier-enable-testing -ownership-verifier-textual-error-dumper -enable-sil-verify-all=0 -o /dev/null %s 2>&1 | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

final class LinkedListNode {
  var next: Optional<LinkedListNode>
  var data: Builtin.Int32
}

// File with known failures involving rebase borrows.

sil @get_linkedlist_node : $@convention(thin) () -> @owned LinkedListNode

// CHECK: fofofofofofofofof
sil [ossa] @ll_iterative_readonly_search_with_invalid_write : $@convention(thin) (@guaranteed LinkedListNode, @guaranteed LinkedListNode, Builtin.Int32) -> @owned Optional<LinkedListNode> {
bb0(%0 : @guaranteed $LinkedListNode, %0bad : @guaranteed $LinkedListNode, %1 : $Builtin.Int32):
  br bb1

bb1:
  %0a = begin_borrow %0 : $LinkedListNode
  br bb2(%0a : $LinkedListNode)

bb2(%inductionVar : @guaranteed $LinkedListNode):
  br bb3

bb3:
  %value = ref_element_addr %inductionVar : $LinkedListNode, #LinkedListNode.data
  %testVal = load [trivial] %value : $*Builtin.Int32
  %cmpResult = builtin "cmp_slt_Int32"(%testVal : $Builtin.Int32, %1 : $Builtin.Int32) : $Builtin.Int1
  cond_br %cmpResult, bb4, bb5

bb4:
  %addr = ref_element_addr %inductionVar : $LinkedListNode, #LinkedListNode.next
  %loadVal = load_borrow %addr : $*Optional<LinkedListNode>
  switch_enum %loadVal : $Optional<LinkedListNode>, case #Optional.some!enumelt: bb4a, case #Optional.none!enumelt: bb4b

// We do not use the unwrapped value here since we need to ensure that the new
// induction variable is a borrow introducer, not a sub borrow.
bb4a(%unwrappedLoadedVal : @guaranteed $LinkedListNode):
  end_borrow %loadVal : $Optional<LinkedListNode>
  %unwrappedAddr = unchecked_take_enum_data_addr %addr : $*Optional<LinkedListNode>, #Optional.some!enumelt
  %loadedUnwrappedVal = load_borrow %unwrappedAddr : $*LinkedListNode
  %f = function_ref @get_linkedlist_node : $@convention(thin) () -> @owned LinkedListNode
  %newBad = apply %f() : $@convention(thin) () -> @owned LinkedListNode
  %nextVar = rebase_borrow %loadedUnwrappedVal : $LinkedListNode on %newBad : $LinkedListNode
  end_borrow %loadedUnwrappedVal : $LinkedListNode
  end_borrow %inductionVar : $LinkedListNode
  destroy_value %newBad : $LinkedListNode
  br bb2(%nextVar : $LinkedListNode)

bb4b:
  %noneResult = enum $Optional<LinkedListNode>, #Optional.none!enumelt
  end_borrow %loadVal : $Optional<LinkedListNode>
  end_borrow %inductionVar : $LinkedListNode
  br bb6(%noneResult : $Optional<LinkedListNode>)

bb5:
  %result = copy_value %inductionVar : $LinkedListNode
  end_borrow %inductionVar : $LinkedListNode
  %wrappedResult = enum $Optional<LinkedListNode>, #Optional.some!enumelt, %result : $LinkedListNode
  br bb6(%wrappedResult : $Optional<LinkedListNode>)

bb6(%wrappedResult2 : @owned $Optional<LinkedListNode>):
  return %wrappedResult2 : $Optional<LinkedListNode>
}
