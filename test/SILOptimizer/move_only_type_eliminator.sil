// RUN: %target-sil-opt -enable-sil-verify-all -sil-trivial-move-only-type-eliminator  %s | %FileCheck %s

sil_stage raw

import Builtin

//////////////////
// Declarations //
//////////////////

struct Trivial {
  var value: Builtin.Int32
}

enum FakeOptional<T> {
case none
case some(T)
}

struct TrivialPair {
  var lhs: Trivial
  var rhs: Trivial
}

sil @use_trivial : $@convention(thin) (Trivial) -> ()

class Klass {}
struct KlassPair {
  var lhs: Klass
  var rhs: Klass
}

sil @use_klass : $@convention(thin) (@guaranteed Klass) -> ()

///////////
// Tests //
///////////

// CHECK-LABEL: sil [ossa] @simple_copy_borrow_value : $@convention(thin) (Trivial) -> () {
// CHECK: bb0(%0 : $Trivial):
// CHECK-NEXT: function_ref use_trivial
// CHECK-NEXT: %1 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT: %2 = apply %1(%0) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK-NEXT: } // end sil function 'simple_copy_borrow_value'
sil [ossa] @simple_copy_borrow_value : $@convention(thin) (Trivial) -> () {
bb0(%0 : $Trivial):
  %1 = copyable_to_moveonly %0 : $Trivial
  %2 = copy_value %1 : $@moveOnly Trivial
  %3 = begin_borrow %2 : $@moveOnly Trivial
  %4 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
  %5 = moveonly_to_copyable [guaranteed] %3 : $@moveOnly Trivial
  apply %4(%5) : $@convention(thin) (Trivial) -> ()
  end_borrow %3 : $@moveOnly Trivial
  destroy_value %2 : $@moveOnly Trivial
  destroy_value %1 : $@moveOnly Trivial
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_load_store : $@convention(thin) (Trivial) -> () {
// CHECK: bb0(%0 : $Trivial):
// CHECK-NEXT: function_ref use_trivial
// CHECK-NEXT:  %1 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:  %2 = alloc_stack $Trivial
// CHECK-NEXT:  store %0 to [trivial] %2 : $*Trivial
// CHECK-NEXT:  %4 = load [trivial] %2 : $*Trivial
// CHECK-NEXT:  %5 = apply %1(%4) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:  %6 = load [trivial] %2 : $*Trivial
// CHECK-NEXT:  %7 = apply %1(%6) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:  destroy_addr %2 : $*Trivial
// CHECK-NEXT:  dealloc_stack %2 : $*Trivial
// CHECK-NEXT:  tuple
// CHECK-NEXT:  return
// CHECK-NEXT: } // end sil function 'simple_load_store'
sil [ossa] @simple_load_store : $@convention(thin) (Trivial) -> () {
bb0(%0 : $Trivial):
  %f = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()

  %alloc = alloc_stack $@moveOnly Trivial
  %1 = copyable_to_moveonly %0 : $Trivial
  store %1 to [init] %alloc : $*@moveOnly Trivial
  %2 = load [copy] %alloc : $*@moveOnly Trivial
  %2a = begin_borrow %2 : $@moveOnly Trivial
  %3 = moveonly_to_copyable [guaranteed] %2a : $@moveOnly Trivial
  apply %f(%3) : $@convention(thin) (Trivial) -> ()
  end_borrow %2a : $@moveOnly Trivial
  destroy_value %2 : $@moveOnly Trivial

  %4 = load_borrow %alloc : $*@moveOnly Trivial
  %5 = moveonly_to_copyable [guaranteed] %4 : $@moveOnly Trivial
  apply %f(%5) : $@convention(thin) (Trivial) -> ()
  end_borrow %4 : $@moveOnly Trivial

  destroy_addr %alloc : $*@moveOnly Trivial
  dealloc_stack %alloc : $*@moveOnly Trivial

  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_load_storeborrow : $@convention(thin) (Trivial) -> () {
// CHECK: bb0(%0 : $Trivial):
// CHECK-NEXT: function_ref use_trivial
// CHECK-NEXT:  %1 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:  %2 = alloc_stack $Trivial
// CHECK-NEXT:  store %0 to [trivial] %2 : $*Trivial
// CHECK-NEXT:  %4 = load [trivial] %2 : $*Trivial
// CHECK-NEXT:  %5 = apply %1(%4) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:  %6 = load [trivial] %2 : $*Trivial
// CHECK-NEXT:  %7 = apply %1(%6) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:  dealloc_stack %2 : $*Trivial
// CHECK-NEXT:  tuple
// CHECK-NEXT:  return
// CHECK-NEXT: } // end sil function 'simple_load_storeborrow'
sil [ossa] @simple_load_storeborrow : $@convention(thin) (Trivial) -> () {
bb0(%0 : $Trivial):
  %f = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()

  %alloc = alloc_stack $@moveOnly Trivial
  %1 = copyable_to_moveonly %0 : $Trivial
  %1a = begin_borrow %1 : $@moveOnly Trivial
  store_borrow %1a to %alloc : $*@moveOnly Trivial
  %2 = load [copy] %alloc : $*@moveOnly Trivial
  %2a = begin_borrow %2 : $@moveOnly Trivial
  %3 = moveonly_to_copyable [guaranteed] %2a : $@moveOnly Trivial
  apply %f(%3) : $@convention(thin) (Trivial) -> ()
  end_borrow %2a : $@moveOnly Trivial
  destroy_value %2 : $@moveOnly Trivial

  %4 = load_borrow %alloc : $*@moveOnly Trivial
  %5 = moveonly_to_copyable [guaranteed] %4 : $@moveOnly Trivial
  apply %f(%5) : $@convention(thin) (Trivial) -> ()
  end_borrow %4 : $@moveOnly Trivial

  end_borrow %1a : $@moveOnly Trivial
  destroy_value %1 : $@moveOnly Trivial
  dealloc_stack %alloc : $*@moveOnly Trivial

  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_struct_aggregate_usage : $@convention(thin) (Trivial, Trivial) -> TrivialPair {
// CHECK: bb0(%0 : $Trivial, %1 : $Trivial):
// CHECK-NEXT:   // function_ref use_trivial
// CHECK-NEXT:   %2 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:   %3 = struct $TrivialPair (%0 : $Trivial, %1 : $Trivial)
// CHECK-NEXT:   %4 = struct_extract %3 : $TrivialPair, #TrivialPair.lhs
// CHECK-NEXT:   %5 = apply %2(%4) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:   return %3 : $Trivial
// CHECK: } // end sil function 'simple_struct_aggregate_usage'
sil [ossa] @simple_struct_aggregate_usage : $@convention(thin) (Trivial, Trivial) -> TrivialPair {
bb0(%0 : $Trivial, %1 : $Trivial):
  %f = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()

  %0a = copyable_to_moveonly %0 : $Trivial
  %1a = copyable_to_moveonly %1 : $Trivial
  %2 = struct $@moveOnly TrivialPair (%0a : $@moveOnly Trivial, %1a : $@moveOnly Trivial)
  %2b = begin_borrow %2 : $@moveOnly TrivialPair
  %ext = struct_extract %2b : $@moveOnly TrivialPair, #TrivialPair.lhs
  %extCpy = moveonly_to_copyable [guaranteed] %ext : $@moveOnly Trivial
  apply %f(%extCpy) : $@convention(thin) (Trivial) -> ()
  end_borrow %2b : $@moveOnly TrivialPair
  %3 = copy_value %2 : $@moveOnly TrivialPair
  destroy_value %2 : $@moveOnly TrivialPair
  %result = moveonly_to_copyable [owned] %3 : $@moveOnly TrivialPair
  return %result : $TrivialPair
}

// TODO: Tuple doesn't compose the same way. Add tuple test case!

// XHECK-LABEL: sil [ossa] @simple_tuple_aggregate_usage : $@convention(thin) (Trivial, Trivial) -> TrivialPair {
// XHECK: bb0(%0 : $Trivial, %1 : $Trivial):
// XHECK-NEXT:   // function_ref use_trivial
// XHECK-NEXT:   %2 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
// XHECK-NEXT:   %3 = tuple $TrivialPair (%0 : $Trivial, %1 : $Trivial)
// XHECK-NEXT:   %4 = tuple_extract %3 : $TrivialPair, #TrivialPair.lhs
// XHECK-NEXT:   %5 = apply %2(%4) : $@convention(thin) (Trivial) -> ()
// XHECK-NEXT:   return %3 : $Trivial
// XHECK: } // end sil function 'simple_tuple_aggregate_usage'
/*
sil [ossa] @simple_tuple_aggregate_usage : $@convention(thin) (Trivial, Trivial) -> TrivialPair {
bb0(%0 : $Trivial, %1 : $Trivial):
  %f = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()

  %0a = copyable_to_moveonly %0 : $Trivial
  %1a = copyable_to_moveonly %1 : $Trivial
  %2 = tuple (%0a : $@moveOnly Trivial, %1a : $@moveOnly Trivial)
  %2b = begin_borrow %2 : $(@moveOnly Trivial, @moveOnly Trivial)
  %ext = tuple_extract %2b : $(@moveOnly Trivial, @moveOnly Trivial), 0
  %extCpy = moveonly_to_copyable [guaranteed] %ext : $@moveOnly Trivial
  apply %f(%extCpy) : $@convention(thin) (Trivial) -> ()
  end_borrow %2b : $(@moveOnly Trivial, @moveOnly Trivial)
  %3 = copy_value %2 : $(@moveOnly Trivial, @moveOnly Trivial)
  destroy_value %2 : $(@moveOnly Trivial, @moveOnly Trivial)
  %result = moveonly_to_copyable [owned] %3 : $(@moveOnly Trivial, @moveOnly Trivial)
  return %result : $(@moveOnly Trivial, @moveOnly Trivial)
}
*/

// CHECK-LABEL: sil [ossa] @simple_enum_aggregate_usage : $@convention(thin) (Trivial) -> FakeOptional<Trivial> {
// CHECK: bb0(%0 : $Trivial):
// CHECK-NEXT:   // function_ref use_trivial
// CHECK-NEXT:   %1 = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:   %2 = enum $FakeOptional<Trivial>, #FakeOptional.some!enumelt, %0 : $Trivial
// CHECK-NEXT:   %3 = unchecked_enum_data %2 : $FakeOptional<Trivial>, #FakeOptional.some!enumelt
// CHECK-NEXT:   %4 = apply %1(%3) : $@convention(thin) (Trivial) -> ()
// CHECK-NEXT:   return %2
// CHECK: } // end sil function 'simple_enum_aggregate_usage'
sil [ossa] @simple_enum_aggregate_usage : $@convention(thin) (Trivial) -> FakeOptional<Trivial> {
bb0(%0 : $Trivial):
  %f = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()

  %0a = copyable_to_moveonly %0 : $Trivial

  %2 = enum $@moveOnly FakeOptional<Trivial>, #FakeOptional.some!enumelt, %0a : $@moveOnly Trivial

  %2b = begin_borrow %2 : $@moveOnly FakeOptional<Trivial>
  %ext = unchecked_enum_data %2b : $@moveOnly FakeOptional<Trivial>, #FakeOptional.some!enumelt
  %extCpy = moveonly_to_copyable [guaranteed] %ext : $@moveOnly Trivial
  apply %f(%extCpy) : $@convention(thin) (Trivial) -> ()
  end_borrow %2b : $@moveOnly FakeOptional<Trivial>
  %3 = copy_value %2 : $@moveOnly FakeOptional<Trivial>
  destroy_value %2 : $@moveOnly FakeOptional<Trivial>
  %result = moveonly_to_copyable [owned] %3 : $@moveOnly FakeOptional<Trivial>
  return %result : $FakeOptional<Trivial>
}

// CHECK-LABEL: sil [ossa] @simple_switch_enum : $@convention(thin) (Trivial) -> FakeOptional<Trivial> {
// CHECK: bb0(%0 : $Trivial):
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: @owned
// CHECK-NOT: @moveOnly
// CHECK: } // end sil function 'simple_switch_enum'
sil [ossa] @simple_switch_enum : $@convention(thin) (Trivial) -> FakeOptional<Trivial> {
bb0(%0 : $Trivial):
  %f = function_ref @use_trivial : $@convention(thin) (Trivial) -> ()
  %0a = copyable_to_moveonly %0 : $Trivial
  debug_value %0a : $@moveOnly Trivial, let, name "foo"
  %2 = enum $@moveOnly FakeOptional<Trivial>, #FakeOptional.some!enumelt, %0a : $@moveOnly Trivial

  switch_enum %2 : $@moveOnly FakeOptional<Trivial>, case #FakeOptional.some!enumelt: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%2Payload : @owned $@moveOnly Trivial):
  %2b = enum $@moveOnly FakeOptional<Trivial>, #FakeOptional.some!enumelt, %2Payload : $@moveOnly Trivial
  br bb3(%2b : $@moveOnly FakeOptional<Trivial>)

bb2:
  %2c = enum $@moveOnly FakeOptional<Trivial>, #FakeOptional.none!enumelt
  br bb3(%2c : $@moveOnly FakeOptional<Trivial>)

bb3(%result : @owned $@moveOnly FakeOptional<Trivial>):
  %result2 = moveonly_to_copyable [owned] %result : $@moveOnly FakeOptional<Trivial>
  return %result2 : $FakeOptional<Trivial>
}

/////////////////
// Klass Tests //
/////////////////

// CHECK-LABEL: sil [ossa] @simple_klass_copy_borrow_value : $@convention(thin) (@guaranteed Klass) -> () {
// CHECK: bb0(%0 : @guaranteed $Klass):
// CHECK-NOT: @moveOnly
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: moveonly_to_copyable
// CHECK: } // end sil function 'simple_klass_copy_borrow_value'
sil [ossa] @simple_klass_copy_borrow_value : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %1aa = copy_value %0 : $Klass
  %1 = copyable_to_moveonly %1aa : $Klass
  %2 = copy_value %1 : $@moveOnly Klass
  %3 = begin_borrow %2 : $@moveOnly Klass
  %4 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %5 = moveonly_to_copyable [guaranteed] %3 : $@moveOnly Klass
  apply %4(%5) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %3 : $@moveOnly Klass
  destroy_value %2 : $@moveOnly Klass
  destroy_value %1 : $@moveOnly Klass
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_klass_load_store : $@convention(thin) (@guaranteed Klass) -> () {
// CHECK: bb0(%0 : @guaranteed $Klass):
// CHECK-NOT: @moveOnly
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: moveonly_to_copyable
// CHECK: } // end sil function 'simple_klass_load_store'
sil [ossa] @simple_klass_load_store : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()

  %alloc = alloc_stack $@moveOnly Klass
  %1aa = copy_value %0 : $Klass
  %1 = copyable_to_moveonly %1aa : $Klass
  store %1 to [init] %alloc : $*@moveOnly Klass
  %2 = load [copy] %alloc : $*@moveOnly Klass
  %2a = begin_borrow %2 : $@moveOnly Klass
  %3 = moveonly_to_copyable [guaranteed] %2a : $@moveOnly Klass
  apply %f(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %2a : $@moveOnly Klass
  destroy_value %2 : $@moveOnly Klass

  %4 = load_borrow %alloc : $*@moveOnly Klass
  %5 = moveonly_to_copyable [guaranteed] %4 : $@moveOnly Klass
  apply %f(%5) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %4 : $@moveOnly Klass

  destroy_addr %alloc : $*@moveOnly Klass
  dealloc_stack %alloc : $*@moveOnly Klass

  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_klass_load_storeborrow : $@convention(thin) (@guaranteed Klass) -> () {
// CHECK: bb0(%0 : @guaranteed $Klass):
// CHECK-NOT: @moveOnly
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: moveonly_to_copyable
// CHECK: } // end sil function 'simple_klass_load_storeborrow'
sil [ossa] @simple_klass_load_storeborrow : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Klass):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()

  %alloc = alloc_stack $@moveOnly Klass
  %1aa = copy_value %0 : $Klass
  %1 = copyable_to_moveonly %1aa : $Klass
  %1a = begin_borrow %1 : $@moveOnly Klass
  store_borrow %1a to %alloc : $*@moveOnly Klass
  %2 = load [copy] %alloc : $*@moveOnly Klass
  %2a = begin_borrow %2 : $@moveOnly Klass
  %3 = moveonly_to_copyable [guaranteed] %2a : $@moveOnly Klass
  apply %f(%3) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %2a : $@moveOnly Klass
  destroy_value %2 : $@moveOnly Klass

  %4 = load_borrow %alloc : $*@moveOnly Klass
  %5 = moveonly_to_copyable [guaranteed] %4 : $@moveOnly Klass
  apply %f(%5) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %4 : $@moveOnly Klass

  end_borrow %1a : $@moveOnly Klass
  destroy_value %1 : $@moveOnly Klass
  dealloc_stack %alloc : $*@moveOnly Klass

  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_klass_struct_aggregate_usage : $@convention(thin) (@guaranteed Klass, @guaranteed Klass) -> @owned KlassPair {
// CHECK-NOT: @moveOnly
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: moveonly_to_copyable
// CHECK: } // end sil function 'simple_klass_struct_aggregate_usage'
sil [ossa] @simple_klass_struct_aggregate_usage : $@convention(thin) (@guaranteed Klass, @guaranteed Klass) -> @owned KlassPair {
bb0(%0 : @guaranteed $Klass, %1 : @guaranteed $Klass):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %0aa = copy_value %0 : $Klass
  %1aa = copy_value %1 : $Klass
  %0a = copyable_to_moveonly %0aa : $Klass
  %1a = copyable_to_moveonly %1aa : $Klass
  %2 = struct $@moveOnly KlassPair (%0a : $@moveOnly Klass, %1a : $@moveOnly Klass)
  %2b = begin_borrow %2 : $@moveOnly KlassPair
  %ext = struct_extract %2b : $@moveOnly KlassPair, #KlassPair.lhs
  %extCpy = moveonly_to_copyable [guaranteed] %ext : $@moveOnly Klass
  apply %f(%extCpy) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %2b : $@moveOnly KlassPair
  %3 = copy_value %2 : $@moveOnly KlassPair
  destroy_value %2 : $@moveOnly KlassPair
  %result = moveonly_to_copyable [owned] %3 : $@moveOnly KlassPair
  return %result : $KlassPair
}

// TODO: Tuple doesn't compose the same way. Add tuple test case!

// XHECK-LABEL: sil [ossa] @simple_klass_tuple_aggregate_usage : $@convention(thin) (Klass, Klass) -> KlassPair {
// XHECK: bb0(%0 : $Klass, %1 : $Klass):
// XHECK-NEXT:   // function_ref use_klass
// XHECK-NEXT:   %2 = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
// XHECK-NEXT:   %3 = tuple $KlassPair (%0 : $Klass, %1 : $Klass)
// XHECK-NEXT:   %4 = tuple_extract %3 : $KlassPair, #KlassPair.lhs
// XHECK-NEXT:   %5 = apply %2(%4) : $@convention(thin) (@guaranteed Klass) -> ()
// XHECK-NEXT:   return %3 : $Klass
// XHECK: } // end sil function 'simple_klass_tuple_aggregate_usage'
/*
sil [ossa] @simple_klass_tuple_aggregate_usage : $@convention(thin) (Klass, Klass) -> KlassPair {
bb0(%0 : $Klass, %1 : $Klass):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()

  %0a = copyable_to_moveonly %0 : $Klass
  %1a = copyable_to_moveonly %1 : $Klass
  %2 = tuple (%0a : $@moveOnly Klass, %1a : $@moveOnly Klass)
  %2b = begin_borrow %2 : $(@moveOnly Klass, @moveOnly Klass)
  %ext = tuple_extract %2b : $(@moveOnly Klass, @moveOnly Klass), 0
  %extCpy = moveonly_to_copyable [guaranteed] %ext : $@moveOnly Klass
  apply %f(%extCpy) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %2b : $(@moveOnly Klass, @moveOnly Klass)
  %3 = copy_value %2 : $(@moveOnly Klass, @moveOnly Klass)
  destroy_value %2 : $(@moveOnly Klass, @moveOnly Klass)
  %result = moveonly_to_copyable [owned] %3 : $(@moveOnly Klass, @moveOnly Klass)
  return %result : $(@moveOnly Klass, @moveOnly Klass)
}
*/

// CHECK-LABEL: sil [ossa] @simple_klass_enum_aggregate_usage : $@convention(thin) (@guaranteed Klass) -> @owned FakeOptional<Klass> {
// CHECK-NOT: @moveOnly
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: moveonly_to_copyable
// CHECK: } // end sil function 'simple_klass_enum_aggregate_usage'
sil [ossa] @simple_klass_enum_aggregate_usage : $@convention(thin) (@guaranteed Klass) -> @owned FakeOptional<Klass> {
bb0(%0 : @guaranteed $Klass):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %0aa = copy_value %0 : $Klass
  %0a = copyable_to_moveonly %0aa : $Klass

  %2 = enum $@moveOnly FakeOptional<Klass>, #FakeOptional.some!enumelt, %0a : $@moveOnly Klass

  %2b = begin_borrow %2 : $@moveOnly FakeOptional<Klass>
  %ext = unchecked_enum_data %2b : $@moveOnly FakeOptional<Klass>, #FakeOptional.some!enumelt
  %extCpy = moveonly_to_copyable [guaranteed] %ext : $@moveOnly Klass
  apply %f(%extCpy) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %2b : $@moveOnly FakeOptional<Klass>
  %3 = copy_value %2 : $@moveOnly FakeOptional<Klass>
  destroy_value %2 : $@moveOnly FakeOptional<Klass>
  %result = moveonly_to_copyable [owned] %3 : $@moveOnly FakeOptional<Klass>
  return %result : $FakeOptional<Klass>
}

// CHECK-LABEL: sil [ossa] @simple_klass_switch_enum : $@convention(thin) (@guaranteed Klass) -> @owned FakeOptional<Klass> {
// CHECK-NOT: copyable_to_moveonly
// CHECK-NOT: moveonly_to_copyable
// CHECK-NOT: @moveOnly
// CHECK: } // end sil function 'simple_klass_switch_enum'
sil [ossa] @simple_klass_switch_enum : $@convention(thin) (@guaranteed Klass) -> @owned FakeOptional<Klass> {
bb0(%0 : @guaranteed $Klass):
  %f = function_ref @use_klass : $@convention(thin) (@guaranteed Klass) -> ()
  %0aa = copy_value %0 : $Klass
  %0a = copyable_to_moveonly %0aa : $Klass
  debug_value %0a : $@moveOnly Klass, let, name "foo"
  %2 = enum $@moveOnly FakeOptional<Klass>, #FakeOptional.some!enumelt, %0a : $@moveOnly Klass

  switch_enum %2 : $@moveOnly FakeOptional<Klass>, case #FakeOptional.some!enumelt: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%2Payload : @owned $@moveOnly Klass):
  %2b = enum $@moveOnly FakeOptional<Klass>, #FakeOptional.some!enumelt, %2Payload : $@moveOnly Klass
  br bb3(%2b : $@moveOnly FakeOptional<Klass>)

bb2:
  %2c = enum $@moveOnly FakeOptional<Klass>, #FakeOptional.none!enumelt
  br bb3(%2c : $@moveOnly FakeOptional<Klass>)

bb3(%result : @owned $@moveOnly FakeOptional<Klass>):
  %result2 = moveonly_to_copyable [owned] %result : $@moveOnly FakeOptional<Klass>
  return %result2 : $FakeOptional<Klass>
}
